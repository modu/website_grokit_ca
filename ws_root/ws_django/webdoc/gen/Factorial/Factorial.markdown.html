<h1>C++ Interview Question: Factorial</h1>
<p><strong>Implement the factorial function</strong>.</p>
<ul>
<li>
<p>What is the approximate order of growth of this function?</p>
<ul>
<li>Approximately for what input 'x' will you get an overflow if using 32 bit uint to compute?</li>
</ul>
</li>
<li>
<p>How can you detect overflow?</p>
</li>
</ul>
<h1>Solution</h1>
<h2>Approximate Order of Growth of Factorial</h2>
<p>The factorial of n is the computation of: n(n-1)(n-2)(n-2)...(1) 'n' times. The conventional math definition is:</p>
<p>$$n!=\prod_{k=1}^n k !$$</p>
<p>If you upper-bound that by approximating with n(n)(n)...(n) &gt;= n(n-1)(n-2)(n-2)...(1). You can then upper-bound \(n!\) by \(n^n\).</p>
<h3>Approximately for what Input 'x' will you get an Overflow if Using 32 bit uint to Compute?</h3>
<p>So let's say that you use C++ unsigned int to computer factorial. You know that the maximum value you can represent with the 32-bit integer is \(2^{32}\). So what you are asking yourself is the solution to: \( n^{n} = 2^{32} \). Taking the logarithm of n on both side doesn't help much. What you can do to approximate the answer is fix the base to two. \( 2^{n} = 2^{32} \) when n = 32 obviously. Since in n! the base is much larger (32), you know that the answer is n &lt;&lt; 32. Now, if you use n = 8. You can see that as \( 8^{8} = {2^{3}}^{8} = 2^{24} \). So you know that 8 is fine. Using 16: \( 16^{16} = {2^{4}}^{16} = 2^{64} \). So 16 is too large. We have a pretty good ballpark number of somewhere between factorial(8) and factorial(16) you will overflow a 32 bit uint. The actual answer is 13:</p>
<pre><code>    n   n!
    0   1
    1   1
    2   2
    3   6
    4   24
    5   120
    6   720
    7   5040
    8   40320
    9   362880
    10  3628800
    11  39916800
    12  479001600
    13  6227020800
    14  87178291200

    ==&gt;
    factorial(12) = 479001600
    2^32          = 4294967296
    factorial(13) = 6227020800
</code></pre>
<h2>How to Detect Overflow</h2>
<p>This is more tricky than it seems. </p>
<ul>
<li>
<p>You can implement multiplication by x as x additions. This is of course slower but you will catch all overflows.</p>
</li>
<li>
<p>You can check the CPU register for overflow (in C#, the 'checked' operand allows you to do that).</p>
</li>
<li>
<p>Some compilers allow you go get a signal when there is an overflow (e.g: gcc -&gt; -ftrapv).</p>
</li>
<li>
<p>Can compute the logarithm of the numbers to multiply (that gives you the number of 0s)</p>
<ul>
<li>Something very similar and more legit would be to count the number of 0 (in base 2 or 10). You can tell if it will overflow (or be 'very close to overflow') then by rounding to the next base-X number.</li>
</ul>
</li>
</ul>
<h2>Integer Arithmetic for Arbitrary Large Numbers</h2>
<p>If you implement a number primitive which is mapped to an arbitrary, expendable set of bits, then you can always return the correct result without having to worry about overflow.</p>
<h2>Importance of n! in Combinatorics</h2>
<p>n! is the number of possible permutations of n different objects. For example, if you have the set: {a, b, c}, you can organize it in the following orders:</p>
<pre><code>{a, b, c}
{a, c, b}
{b, a, c}
{b, c, a}
{c, a, b}
{c, b, a}
</code></pre>
<p>You have 6 possible orders, this is equal to the factorial of the size of your set (3! = 6). This is easy to see why if you think of the possibles in the terms of putting an item in a box. You begin with 3 empty boxes:</p>
<pre><code>{}{}{}
</code></pre>
<p>Now, when you choose the item for the first box, you have three choices: {a, b, c}. Your 3 possible choices are picking {a, b or c}.</p>
<pre><code>{a}{}{}

{b}{}{}

{c}{}{}
</code></pre>
<p>Now, when you select the second item, you only have <strong>2</strong> choices left:</p>
<pre><code>{a}{b}{}
{a}{c}{}

{b}{a}{}
{b}{c}{}

{c}{a}{}
{c}{b}{}
</code></pre>
<p>... and the next step you only have one choice. Therefore, the first step you have 3 choices. Each of these choice can fork into two choices. The number of possibilities is therefore (3)x(2)x(1) = 3!</p>
<h1>Code</h1>
<p><strong>[Inserted file: factorial.cpp.]</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;limits&gt;
#include &lt;string&gt;

using namespace std;

unsigned int factorialRecursive(unsigned int n)
{
    assert(n &gt;= 0);
    if(n &gt; 1)
    return n * factorialRecursive(n - 1);
    else
    return 1;
}

unsigned int factorialLoop(unsigned int n)
{
    if(n &lt;= 1)
        return 1;

    int fact = 1;
    for(int i = 2; i &lt;= n; ++i)
    {
        // Here you cannot simply check that fact*i &lt; fact in order
        // to guard against overflows -- you have no guarantee that
        // fact*i won't overflow into something &gt; fact.
        fact = fact * i;
    }

    return fact;
}

// This is slow: O(n^2) instead of O(n), but you are guaranteed to
// know when there is an overflow.
unsigned int factorialAdd(unsigned int n)
{
    if(n &lt;= 1)
        return 1;

    int fact = 1;
    for(int i = 2; i &lt;= n; ++i)
    {
        if(fact &gt; numeric_limits&lt;unsigned int&gt;::max())
        {
            throw "Overflow pre-detect.";
        }

        // Implement multiplication as an addition.
        int sum = 0;
        for(int j = 0; j &lt; i; ++j)
        {
            if(sum + fact &lt; sum)
            {
                throw "Overflow detect";
            }

            sum = sum + fact;
        }
        fact = sum;
    }

    return fact;
}

unsigned char factorialLoopShowOverflow(unsigned char n)
{
    if(n &lt;= 1)
        return 1;

    unsigned char fact = 1;
    for(unsigned char i = 2; i &lt;= n; ++i)
    {
        fact = fact * i;
    }

    return fact;
}

// This is a nice "academic" example of using the C++ template system,
// but not very useful in practice.
template&lt;int N&gt;
class Factorial
{
public:
    static const int value = N * Factorial&lt;N - 1&gt;::value;
};

template&lt;&gt;
class Factorial&lt;0&gt;
{
public:
    static const int value = 1;
};

void testFactorial(unsigned int(*fnPtr)(unsigned int))
{
    assert( fnPtr(10) == 3628800 );
    assert( fnPtr(0) == 1 );
    assert( fnPtr(1) == 1 );
    assert( fnPtr(3) == 6 );
}

void printFactorial(unsigned int(*fnPtr)(unsigned int), string name)
{
    cout&lt;&lt;name&lt;&lt;":"&lt;&lt;endl;
    try
    {
        for(unsigned int i = 0; i &lt; 15; ++i)
        {
            cout&lt;&lt;i&lt;&lt;": "&lt;&lt;fnPtr(i)&lt;&lt;endl;
        }
    }
    catch(...)
    {
        cout&lt;&lt;"Function signaled error, stopping."&lt;&lt;endl;
    }
}

int main()
{
    cout&lt;&lt;"Begin"&lt;&lt;endl;

    //Cannot be used in a function with arbitrary parameter,
    //the value has to be known at compile time to be used
    //in template.
    //(see C2971)
    cout&lt;&lt; Factorial&lt;10&gt;::value &lt;&lt;endl;
    // cout&lt;&lt; Factorial&lt;100&gt;::value &lt;&lt;endl; This would blow-up the compiler.


    printFactorial( &amp;factorialLoop, "factorialLoop" );
    printFactorial( &amp;factorialRecursive, "factorialRecursive" );
    printFactorial( &amp;factorialAdd, "factorialAdd" );

    cout&lt;&lt;"factorialLoopShowOverflow:"&lt;&lt;endl;
    for(unsigned char i = 0; i &lt; 12; ++i)
    {
        cout&lt;&lt;(unsigned int)i&lt;&lt;": "&lt;&lt;(unsigned int)factorialLoopShowOverflow(i)&lt;&lt;endl;
    }

    testFactorial( &amp;factorialLoop );
    testFactorial( &amp;factorialRecursive );
    testFactorial( &amp;factorialAdd );

    cout&lt;&lt;"End"&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1>Code Output</h1>
<p><strong>[Inserted file: factorial.cpp.out.]</strong></p>
<pre><code>Begin
3628800
factorialLoop:
0: 1
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
11: 39916800
12: 479001600
13: 1932053504
14: 1278945280
factorialRecursive:
0: 1
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
11: 39916800
12: 479001600
13: 1932053504
14: 1278945280
factorialAdd:
0: 1
1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800
11: 39916800
12: 479001600
Function signaled error, stopping.
factorialLoopShowOverflow:
0: 1
1: 1
2: 2
3: 6
4: 24
5: 120
6: 208
7: 176
8: 128
9: 128
10: 0
11: 0
End
</code></pre>