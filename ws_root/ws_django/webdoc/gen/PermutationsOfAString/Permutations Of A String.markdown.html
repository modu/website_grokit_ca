<h1>C++ Interview Question: Permutations Of A String</h1>
<p>Given a string (e.g: "abc"), generate all possible strings that can be obtained by switching the positions of the letters.</p>
<h2>Discussion</h2>
<p>Note that this is equivalent to the slightly more wonky: given a set of letters of length n, output all n-tuples that can be formed by combining those letters (without repetitions).</p>
<h2>Code</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;

using namespace std;

//!@brief 'Insertion' solution: each letter
//!@note This is a very space-inneficient solution: requires to store
//!      all the possible answers in memory at once.
deque&lt;string&gt; getAllPossiblePermutationsOfStr(const char* cc_str)
{
  //Assume a character that will never be used, for debug
  const char unused_space = '_';
  string str(cc_str);

  string init_str;
  init_str.resize( str.size(), unused_space );

  deque&lt;string&gt; q1;
  deque&lt;string&gt; q2;
  deque&lt;string&gt;&amp; next_queue = q1;
  deque&lt;string&gt;&amp; curr_queue = q2;

  curr_queue.push_back( init_str );

  for(size_t i = 0; i &lt; str.size(); ++i)
  {
    while(!curr_queue.empty())
    {
      string str_curr = curr_queue.front();
      curr_queue.pop_front();
      for(size_t j = 0; j &lt; str_curr.size(); ++j)
      {
        if(str_curr[j] == unused_space)
        {
          string str_add = str_curr;
          str_add[j] = str[i];
          next_queue.push_back(str_add);
        }
      }
    }
    //Swap the queues references
    deque&lt;string&gt;&amp; tmp = curr_queue;
    curr_queue = next_queue;
    next_queue = tmp;
    next_queue.clear();
  }

  return curr_queue;
}

//! @brief 'Insertion' solution, recursive
//! More efficient than the queue version: 1/(strSize) of the tree at time is completely
//! expanded in memory. This has the disadvantage that one char is 'forbidden'.
void allPossiblePermutationsOfStrMarkInStr_Recursive(const char* str, size_t strSize, char* ans, int level = 0)
{
  static const char emptyChar = '_';
  if(level == 0)
    memset(ans, emptyChar, strSize);
  else if (level == strSize)
  {
    cout&lt;&lt;ans&lt;&lt;endl;
    return;
  }

  for(size_t i = 0; i &lt; strSize; ++i)
  {
    if(ans[i] == emptyChar)
    {
      string ans_nextLevel(ans);
      ans_nextLevel[i] = str[level];
      allPossiblePermutationsOfStrMarkInStr_Recursive(str, strSize, (char*)ans_nextLevel.c_str(), level + 1);
    }
  }
}

//! Use a 'bool mask' in order to keep track which letter was used
void allPossiblePermutationsOfStrMarkInArray_RecurseFn(
  const char* str, size_t strSize, char* ans, bool* letterUsed, int recurseLevel)
{
  if(strSize == recurseLevel)
  {
    cout&lt;&lt;ans&lt;&lt;endl;
    return;
  }

  for(size_t iLet = 0; iLet &lt; strSize; ++iLet)
  {
    if(letterUsed[iLet] == false)
    {
      letterUsed[iLet] = true;
      ans[recurseLevel] = str[iLet];
      allPossiblePermutationsOfStrMarkInArray_RecurseFn(str, strSize, ans, letterUsed, recurseLevel + 1);
      letterUsed[iLet] = 0;
    }
  }
}

void allPossiblePermutationsOfStrMarkInArray_Recursive(const char* str, size_t strSize, char* ans)
{
  bool* letterUsed = new bool[strSize];
  memset(letterUsed, false, strSize);
  allPossiblePermutationsOfStrMarkInArray_RecurseFn(str, strSize, ans, letterUsed, 0);
  delete[] letterUsed;
}

template&lt;class T&gt;
void print(const T&amp; v)
{
  for(T::const_iterator it = v.begin(); it!= v.end(); ++it)
  {
    cout&lt;&lt;*it&lt;&lt;endl;
  }
}

int main()
{
  cout&lt;&lt;"Begin"&lt;&lt;endl;

  const char* str = "abc";//auto null-terminated
  const size_t strLen = strlen(str);

  cout&lt;&lt;"Queue solution:"&lt;&lt;endl;
  print( getAllPossiblePermutationsOfStr(str) );

  char* ans = 0 ;

  cout&lt;&lt;"Recursive solution (str marks):"&lt;&lt;endl;
  ans = new char[strLen + 1];
  ans[strLen] = 0;
  allPossiblePermutationsOfStrMarkInStr_Recursive(str, strLen, ans);
  delete[] ans;

  cout&lt;&lt;"Recursive solution (bitmask):"&lt;&lt;endl;
  ans = new char[strLen + 1];
  ans[strLen] = 0;
  allPossiblePermutationsOfStrMarkInArray_Recursive(str, strLen, ans);
  delete[] ans;

  cout&lt;&lt;"End"&lt;&lt;endl;
  return 0;
}
</code></pre>
<h2>C++ Code Output</h2>
<pre><code>Begin
Queue solution:
abc
acb
bac
cab
bca
cba
Recursive solution (str marks):
abc
acb
bac
cab
bca
cba
Recursive solution (bitmask):
abc
acb
bac
bca
cab
cba
End
</code></pre>
<h2>Code (Python)</h2>
<p><strong>[Inserted file: permutations_of_set.py.]</strong></p>
<pre><code>def permut(lset, curr, completeFn):

    if len(lset) == 0:
        completeFn(curr)
        return

    for s in lset:
        lset.remove(s)
        curr.append(s)
        permut(lset, curr, completeFn)
        curr.remove(s)
        lset.add(s)

permut({'a', 'b', 'c'}, [], lambda x: print("".join(x)))
print('\n------\n')
permut({'a', 'b', 'c', 'd'}, [], lambda x: print("".join(x)))
</code></pre>
<h3>Output</h3>
<p><strong>[Inserted file: permutations_of_set.py.out.]</strong></p>
<pre><code>cba
cab
cba
cab
abc
abc

------

cbad
cbda
cabd
cadb
cdba
cdab
cbad
cbda
cabd
cadb
cdba
cdab
abcd
abdc
abcd
abdc
adcb
adcb
dbca
dbac
dbca
dbac
dacb
dacb
</code></pre>
<h1>A Little bit of Math</h1>
<p>For a n-tuple, the first letter has n free choices, the second n-1 and so forth. You end up with a total of n! possible strings.</p>
<h1>A More Difficult Alternative, M-tuples Allowing Repetitions</h1>
<p>Would it be difficult to change the problem to generate all m-tuple from the set of n letters (m &gt;= n) if repetitions are allowed?</p>