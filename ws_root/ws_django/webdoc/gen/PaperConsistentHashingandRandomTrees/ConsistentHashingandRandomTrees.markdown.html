<h1>[Paper Reading Notes] Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web</h1>
<p>This is the famous paper by David K. et al. which introduces two distributed computing concepts: <strong>distributed hashing</strong> and <strong>random trees</strong>.</p>
<p><strong>Link to paper</strong>: <a href="http://dl.acm.org/citation.cfm?id=258660">ACM website for citations</a>, <a href="http://www.cs.princeton.edu/courses/archive/fall09/cos518/papers/chash.pdf">full pdf</a>.</p>
<p><strong>Keywords</strong>: hash function, consistent hashing, random trees, distributed systems.</p>
<h2>Random Trees</h2>
<p><strong>Random trees are introduced to solve the problem of 'hot spots' on the internet.</strong></p>
<p>Let's say you have P web-pages distributed on a server in C' (the set of all servers). Each page p in P maps to a server c in C'. In other words, you use this simple allocation scheme to map p to c:</p>
<pre><code>    h: P -&gt; C'
</code></pre>
<p>... using a simple <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator">linear congruential generator</a>:</p>
<p>$$X_{n+1} = \left( a X_n + c \right)~~\bmod~~m$$</p>
<p>This works fine if the load across all pages p in P is uniform. Unfortunately, on the Internet a minority of pages are likely to receive most of the load. Which mean that with the above allocation of direct page-to-server, most servers will sit idle while a few servers will be overloaded.</p>
<p>The idea behind <em>random trees</em> is to avoid 'hot-spotting' by 1.) assigning an <em>abstract d-ary tree</em> for <strong>each page</strong> with an owner root and 2.) picking a random leaf-to-root path in that tree for every client-side request.</p>
<p>Each page p in P has is associated with a tree (can be generated by a predictable random function seeded by the page name). For example, a web-page is associated with the following server tree (all nodes being servers):</p>
<pre><code>       root
       /   \
      a     b
     / \    / \
    c   d  e   f
</code></pre>
<p>The node 'root' owns the web-page. If a client wants the web-page, it issues a request to <em>a random leaf node of the tree</em>; i.e. it picks a random node in set [c, d, e, f]. If that node does not have the page, it forwards the request to its parent, all the way to root. Since root owns the page, you are guaranteed to eventually hit a server that owns the page.</p>
<p>Every-time a node receives a request for a page, it increments a counter. If that counter reaches a high-enough number, then that node <em>caches the page p</em>.</p>
<p>This relieves the hot-spot problem since a page with low load will only be owned by root and serviced by root. If the load increases, [root, a, b] will start serving that page. If it increases even more, [root, a, b, c, d, e, f] will start serving that page. Since every page has a different random tree, the load is evenly distributed on all <em>leaf</em> servers (some root servers might have higher load, but this is greatly mitigated by the exponential number of nodes downwards that start serving the page as the load increases).</p>
<h2>Consistent Hashing</h2>
<p><strong>Consistent hashing addresses the problem of partial membership view of servers.</strong></p>
<p>If you have a server farm with a constant number of servers that never went down, you can use a normal hash function in order to map a resource to a server. However, since on the Internet servers are added and removed (or go down) all the time, this is not a pragmatic approach.</p>
<p>If a typical hash function (see how a <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator">linear congruential generator</a> can be used to create a hash function) is used, adding or removing one server to your server set would remap all resources (with a (C-1)/C probability), which would be disastrous. <em>What we are looking for is a hash function that minimally changes the membership mapping of resource to server when servers are added or removed</em>. We will call this the <em>smoothness</em> property.</p>
<p>Note that if you accept that the <em>views</em> of servers is not consistent on all servers, an item can always be mapped to more than one server and your client code has to support that. The good thing about consistent hashing, is that the number of servers to which a single resource can be assigned to is low (called the <em>spread</em> property) assuming that the inconsistency in the views is only a few servers. So let's say you have 100 servers, and each of those servers sees 95 other servers properly (with uniform probability of having bad information about a server). A web-page p will still be mapped to a small finite set of servers. If you ask every server is the cloud 'where is page p?', you will get a few different answers (let's say c7, c8, c9). If you used normal hashing, the servers will completely disagree on where the information should be (you could end-up with the complete set [c001...c100] as answers).</p>
<p>If a server caches and returns a page on request, then with a normal hash function all servers will end up having to hold all pages in memory (obviously bad). This is called the <em>load</em> property. Using a consistent hash function, all servers only need to know a subset of all pages p.</p>
<h3>Intuitive Example of Hash function Having Consistent-Hashing-Like Properties</h3>
<p>So, which hash functions have good 'consistent hashing properties' (smoothness, spread and load)?</p>
<p>One way that is easy to understand is to define a hash function that outputs a float between 0 and 1. Then servers from 1...C are spread (randomly or evenly) over that interval. The server closest to the hash output is the server who owns the resource.</p>
<p>Let's say you have 4 (c1, c2, ..., c4) servers and 12 resources (r1, r2, ..., r14) spread on those servers. The view is inconsistent. Some people view this:</p>
<pre><code>      r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12
    0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
         c1        c2        c3        c4

    c1: [r1, r2, r3]
    c2: [r4, r5, r6]
    c3: [r7, r8, r9, r10]
    c4: [r11, r12]
</code></pre>
<p>... and some people never got the heads up that c3 went online, so they view this:</p>
<pre><code>      r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12
    0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
           c1           c2          c4

    c1: [r1, r2, r3, r4]
    c2: [r5, r6, r7, r8, r9]
    c4: [r10, r11, r12]
</code></pre>
<p>So people disagree on who holds r4, r7, r8, r9, r10; 5/12 keys (42%) for a disagreement of 1/4 (25%) of the servers. The theoretical disagreement rate is (R/C)/R = 1/C, which is be 25% (our example uses a silly version of consistent hashing, hence the higher disagreement rate). Using a normal hashing function the disagreement would be (C-1)/C (75%). As C increases, the advantage of consistent hashing over normal hashing will only increase.</p>
<p>A better solution is to have a 0...1 ring instead of a line, but the simple line is enough to get an intuitive understanding of the principle.</p>
<p><strong>Note: this is only an example, never use this as an implementation.</strong> For more information on the actual implementation of a hash function that has consistent hashing properties, refer to the following:</p>
<ul>
<li><a href="http://www8.org/w8-papers/2a-webserver/caching/paper2.html">Paper from the same author that actually goes over the implementation of consistent hashing "Web Caching with Consistent Hashing
"</a>.</li>
<li><a href="https://www.youtube.com/watch?v=jznJKL0CrxM">3 minutes, extremely simple video overview</a>.</li>
<li><a href="http://en.wikipedia.org/wiki/Consistent_hashing">Wikipedia entry</a>.</li>
<li><a href="http://michaelnielsen.org/blog/consistent-hashing/">Example of ring implementation with python code</a>.</li>
</ul>
<h1>Appendix: Hash Function Notation</h1>
<p>For a great overview of hash function notation, see <a href="http://research.microsoft.com/pubs/64588/hash_survey.pdf">section 2.1 of this paper</a>.</p>
<p>The basic thing to understand is that:</p>
<pre><code>    h: P x [1..C] -&gt; C'
</code></pre>
<p>... means that for each webpage p in the set of all webpages P AND each total number of caches from 1 to C, the hash function h maps p to a set C' of servers.</p>
<p>The 'x [1..C]' part is a bit confusing. The basic notation A x B means for each pair of each member a of set A and b of set B. For simplicity's sake you can think of h: P x [1..C] -&gt; C' as "each webpage is mapped to a unique set of servers C', and this mapping changes if the number of servers in C' changes".</p>
<h1>Appendix: Links</h1>
<ul>
<li><a href="http://www.cs.princeton.edu/courses/archive/fall09/cos518">Princeton class on distributed computing with lots of papers</a>.</li>
</ul>