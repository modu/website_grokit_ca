<h1>C++ Interview Question: Byte Padding</h1>
<h2>Question and Notes</h2>
<pre><code>Explain the concept of memory padding.
Given the classes declarations below, can you predict how big they will be?
Can you re-order the member data to have smaller classes?
What would be the output compiled on a 32 bit system? On a 64 bit system?

Notes:
  - The output is architecture/compiler dependent. Be able to __explain__ the result obtained, and discuss what may vary on a diffent compiler/architecture.
  - Compiled/executed as a 32 bit program.
  - See: http://en.wikipedia.org/wiki/Byte_padding
</code></pre>
<h2>Code</h2>
<pre><code>#include &lt;iostream&gt;

using namespace std;

class Class0
{
public:
};

class Class1
{
public:
  static void fn(){}
};

class ClassA
{
public:

  void aFn(){};

  int* a;
};

class ClassB
{
public:

  virtual void aFn(){};

  int* a;
};

//http://en.wikipedia.org/wiki/Virtual_function_pointer#Implementation
class ClassC
{
public:

  virtual void aFn(){};
  virtual void aFn_2(){};

  int* a;
};

//http://en.wikipedia.org/wiki/Byte_padding#Data_structure_padding
class PaddingLoss
{
public:
  char a;
  int b;
};

class PaddingLoss2
{
public:
  int a;
  char b;
};

class PaddingLoss3
{
public:
  int a;
  char b;
  char c;
};

class NoPaddingLoss
{
public:
  int a;
  char b;
  char c;
  char d;
  char e;
};

class PaddingLoss4
{
public:
  int a;
  char b;
  char c;
  char d;
  char e;
  char f;
};

int main()
{
  cout&lt;&lt;"Begin"&lt;&lt;endl;

  cout&lt;&lt; sizeof(Class0) &lt;&lt;endl; //1 byte, see http://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class
  cout&lt;&lt; sizeof(Class1) &lt;&lt;endl; //same
  cout&lt;&lt; sizeof(ClassA) &lt;&lt;endl; //4 bytes for 1 pointer
  cout&lt;&lt; sizeof(ClassB) &lt;&lt;endl; //8 bytes: 1 pointer, 1 virtual table pointer
  cout&lt;&lt; sizeof(ClassC) &lt;&lt;endl; //same, not bigger when add functions

  cout&lt;&lt; sizeof(PaddingLoss) &lt;&lt;endl;   // 8 bytes, char takes 1, int is 4-byte aligned
  cout&lt;&lt; sizeof(PaddingLoss2) &lt;&lt;endl;  // 8 bytes -- class must be 4-byte aligned
  cout&lt;&lt; sizeof(PaddingLoss3) &lt;&lt;endl;  // 8 bytes -- class must be 4-byte aligned
  cout&lt;&lt; sizeof(NoPaddingLoss) &lt;&lt;endl; // 8 bytes: 4 for int, 4*1 for char 
  cout&lt;&lt; sizeof(PaddingLoss4) &lt;&lt;endl;  // 12 bytes -- class must be 4-byte aligned, 
                                       //             one additional byte 'takes' 4

  // 64 bits: still 4-byte-aligned, but pointer consume 8 bytes

  cout&lt;&lt;"End"&lt;&lt;endl;
  return 0;
}
</code></pre>
<h2>Code Output</h2>
<pre><code>Begin
1
1
4
8
8
8
8
8
8
12
End
</code></pre>