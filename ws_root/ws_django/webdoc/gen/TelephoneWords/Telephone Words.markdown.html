<h1>C++ Interview Question: Telephone Words</h1>
<h2>Question and Notes</h2>
<pre><code>On a typical touch-tone telephone, output all the possible letter-numbers combination that a given number can have.

Ex: 
  1 -&gt; A, B or C
  12 -&gt; AD, AE, AF, BD, BE, BF, CD, ...

Notes:
  - Do not forget dealing with C-string: \0 terminated
</code></pre>
<h2>Code</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;deque&gt;
#include &lt;string&gt;

using namespace std;

//@tag find if can have arythmetic way to have this
static const char keypadLookup[] = 
  {
    'A', 'B', 'C', 
    'D', 'E', 'F', 
    'G', 'H', 'I', 
    'J', 'K', 'L', 
    'M', 'N', 'O', 
    'P', 'R', 'S',
    'T', 'U', 'V',
    'W', 'X', 'Y'};

char getCharKey(int telephoneKey, int place)
{
  assert( telephoneKey &gt;= 0 &amp;&amp; telephoneKey &lt;= 9);
  assert( place &gt;= 0 &amp;&amp; place &lt;= 2 );
  if( (telephoneKey == 0 || telephoneKey == 1) &amp;&amp; place == 0 )
  {
    return telephoneKey + (char)'0';
  }

  return keypadLookup[ (telephoneKey-2)*3 + place ];
}

void enumPossibleThenPrint_RecursiveSol(int phoneNumber[], size_t size, char* phoneChars, size_t i)
{
  if(i == size)
  {
    phoneChars[i] = 0;//we allocated size+1 to allow for the null-termination
    cout&lt;&lt;phoneChars&lt;&lt;endl;
    return;
  }

  if(phoneNumber[i] &lt;= 1 || phoneNumber[i] == 9)
  {
    phoneChars[i] = phoneNumber[i] + (int)'0'; //int to char trick
    enumPossibleThenPrint_RecursiveSol(phoneNumber, size, phoneChars, i + 1);
  }
  else
  {
    for(size_t j = 0; j &lt; 3; ++j)
    {
      phoneChars[i] = getCharKey( phoneNumber[i], j );
      enumPossibleThenPrint_RecursiveSol(phoneNumber, size, phoneChars, i + 1);
    }
  }
}

//! Relies on the creation of a queue -- very similar to a breadth-first
//! search in a tree algorithm. This has the disadvantage of requiring to
//! store all the child nodes when visiting a level of the tree -- memory
//! inneficient compared to a depth-first search that does not require that
//! (like the recursive case implemented above or non-recursive after).
void enumPossibleThenPrint(int phoneNumber[], size_t size, deque&lt;string&gt;&amp; dq)
{
  assert( dq.size() == 1 );
  size_t lastLevelCases = 1;
  for(size_t i = 0; i &lt; size; ++i)
  {
    size_t thisLevelCases = 0;
    for(size_t j = 0; j &lt; lastLevelCases; ++j)
    {
      string phoneChars = dq.front();
      phoneChars.append("_");
      dq.pop_front();

      if(phoneNumber[i] &lt;= 1 || phoneNumber[i] == 9)
      {
        phoneChars[i] = phoneNumber[i] + (int)'0'; //int to char trick
        dq.push_back(phoneChars);
        ++thisLevelCases;
      }
      else
      {
        for(size_t k = 0; k &lt; 3; ++k)
        {
          phoneChars[i] = getCharKey( phoneNumber[i], k );
          dq.push_back(phoneChars);
          ++thisLevelCases;
        }
      }
    }
    lastLevelCases = thisLevelCases;
  }

  for(deque&lt;string&gt;::iterator it = dq.begin(); it != dq.end(); ++it)
  {
    cout&lt;&lt;*it&lt;&lt;endl;
  }
}

bool increment_ifCannotGoBackToLowest(char&amp; c, int no)
{
  if(c == '0' || c == '1')
    return false;
  else
  {
    if( c == getCharKey(no, 0) )
    {
      c = getCharKey(no, 1);
      return true;
    }
    else if( c == getCharKey(no, 1) )
    {
      c = getCharKey(no, 2);
      return true;
    }
    else
    {
      c = getCharKey(no, 0);
      return false;
    }
  }
}

void enumPossibleThenPrint_NonRecurFast(int phoneNum[], size_t size)
{
  //Init lowest-value string
  char* phoneNumChars = new char[size+1];
  phoneNumChars[size] = 0;
  for(size_t i = 0; i &lt; size; ++i)
  {
    phoneNumChars[i] = getCharKey( phoneNum[i], 0 );
  }

  //Print base case
  cout&lt;&lt;phoneNumChars&lt;&lt;endl;

  int level = size - 1;
  while(1)
  {
    bool incrSuccess = 
      increment_ifCannotGoBackToLowest( phoneNumChars[level], phoneNum[level] );
    if(incrSuccess == true)
    {
      level = size - 1;
      cout&lt;&lt;phoneNumChars&lt;&lt;endl;
    }
    else
      --level;

    if(level &lt; 0)
      break;
  }

  delete[] phoneNumChars;
}


void printTelephoneWords(int phoneNumber[], size_t size)
{
  cout&lt;&lt;"Recursive solution:"&lt;&lt;endl;
  char* phoneChars = new char[ size + 1 ];
  phoneChars[size] = 0;
  enumPossibleThenPrint_RecursiveSol(phoneNumber, size, phoneChars, 0);
  delete[] phoneChars;

  cout&lt;&lt;"Non-recursive solution:"&lt;&lt;endl;
  deque&lt;string&gt; dq;
  dq.push_back("");//base case
  enumPossibleThenPrint(phoneNumber, size, dq);

  cout&lt;&lt;"Non-recursive solution (fast):"&lt;&lt;endl;
  enumPossibleThenPrint_NonRecurFast(phoneNumber, size);
}

int main()
{
  cout&lt;&lt;"Begin"&lt;&lt;endl;

  int phoneNum[] = {1, 8, 0, 0, 3};
  printTelephoneWords(phoneNum, sizeof(phoneNum)/sizeof(int));

  cout&lt;&lt;"End"&lt;&lt;endl;
  return 0;
}
</code></pre>
<h2>Code Output</h2>
<pre><code>Begin
Recursive solution:
1T00D
1T00E
1T00F
1U00D
1U00E
1U00F
1V00D
1V00E
1V00F
Non-recursive solution:
1T00D
1T00E
1T00F
1U00D
1U00E
1U00F
1V00D
1V00E
1V00F
Non-recursive solution (fast):
1T00D
1T00E
1T00F
1U00D
1U00E
1U00F
1V00D
1V00E
1V00F
End
</code></pre>