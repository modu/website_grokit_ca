<h1>C++ Interview Question: Binary Search Tree, Delete Node (When Tree has No 'Parent' Nodes)</h1>
<h2>Question</h2>
<p>Given a binary search tree (BST) with the following node structure:</p>
<pre><code>    class Node
    {
    public:

        Node* left;
        Node* right;
        int value;
    };
</code></pre>
<p>Given a value v, delete the associated node (or the first one that is found in the tree if duplicate values).</p>
<h1>Code</h1>
<p><strong>[Inserted file: bst_delNoParent.cpp.]</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;stack&gt;
#include &lt;utility&gt;
#include &lt;cassert&gt;
#include &lt;limits&gt;
#include &lt;cstdlib&gt;

using namespace std;

class Node
{
public:

Node()
{
    left = 0;
    right = 0;
    value = -1;
}

Node* left;
Node* right;
int value;
};

class BinarySearchTree
{
public:

BinarySearchTree()
{
    root = 0;
}

Node* getRoot()
{
    return root;
}

void insert(float v)
{
    if(root == 0)
    {
        root = new Node;
        root-&gt;value = v;
        return;
    }

    Node* np = root;

    while(1)
    {
        if( v &lt; np-&gt;value )
        {
            if(np-&gt;left == 0)
            {
                np-&gt;left = new Node;
                np-&gt;left-&gt;value = v;
                return;
            }
            else
            {
                np = np-&gt;left;
            }
        }
        else
        { // &gt;=
            if(np-&gt;right == 0)
            {
                np-&gt;right = new Node;
                np-&gt;right-&gt;value = v;
                return;
            }
            else
            {
                np = np-&gt;right;
            }
        }
    }
}

Node* find(float v)
{
    Node* n = root;

    bool progress = true;
    while (progress)
    {
        progress = false;
        if (v == n-&gt;value)
        {
            return n;
        }
        else if(v &lt; n-&gt;value &amp;&amp; n-&gt;left != 0)
        {
            n = n-&gt;left;
            progress = true;
        }
        else if(v &gt; n-&gt;value &amp;&amp; n-&gt;right != 0)
        {
            n = n-&gt;right;
            progress = true;
        }
    }

    return 0;
}

void deleteNode(float v)
{
    Node* n = this-&gt;root;
    Node* parent = 0;

    bool progress = true;
    while (progress)
    {
        progress = false;
        if (v == n-&gt;value)
        {
            Node t = *n;

            // Convention: always use successor: the leftmost child on the right.
            if(n-&gt;right == 0)
            {
                if(n == this-&gt;root)
                {
                    delete this-&gt;root;
                    this-&gt;root = n;
                }
                else if(parent-&gt;left == n)
                {
                    parent-&gt;left = 0;
                }
                else
                {
                    parent-&gt;right = 0;
                }
            }
            else
            {
                Node* s = findLeftmost(n-&gt;right);
                n-&gt;value = s-&gt;value;
                delLeftmost(n-&gt;right, n);
            }
        }
        else if(v &lt; n-&gt;value &amp;&amp; n-&gt;left != 0)
        {
            parent = n;
            n = n-&gt;left;
            progress = true;
        }
        else if(v &gt; n-&gt;value &amp;&amp; n-&gt;right != 0)
        {
            parent = n;
            n = n-&gt;right;
            progress = true;
        }
    }
}

private:

static Node* findRightmost(Node* n)
{
    while(n-&gt;right != 0)
        n = n-&gt;right;

    return n;
}

static void delLeftmost(Node* n, Node* parent)
{
    while(n-&gt;left != 0)
    {
        parent = n;
        n = n-&gt;left;
    }

    if(parent-&gt;left == n)
        parent-&gt;left = 0;
    else
        parent-&gt;right = 0;

    delete n;
}

static Node* findLeftmost(Node* n)
{
    while(n-&gt;left != 0)
        n = n-&gt;left;

    return n;
}

Node* root;
};

void inorderTraversal(const Node* n, stack&lt;const Node*&gt;* accumulator = 0)
{
    //inorder: left, visit, right    
    if(n == 0)
        return;

    if(n-&gt;left != 0)
        inorderTraversal(n-&gt;left);

    cout&lt;&lt; n-&gt;value &lt;&lt; endl;

    if(accumulator != 0)
    {
        accumulator-&gt;push(n);
    }

    if(n-&gt;right != 0)
        inorderTraversal(n-&gt;right);
}

bool isValidBST(const Node* root)
{
    stack&lt;const Node*&gt; inOrder;

    inorderTraversal(root, &amp;inOrder);

    float last = numeric_limits&lt;float&gt;::min();
    while(inOrder.size() &gt; 0)
    {
        const Node* n = inOrder.top();
        inOrder.pop();

        if(n-&gt;value &lt; last)
        {
            return false;
        }

        last = n-&gt;value;
    }

    return true;
}

// Note that each node in the tree is definitely not equally likely.
// @@a1: fun math problem, devise a function that would yield every node with equal probability.
Node* getRandomNodeInBST(Node* root)
{
    int choice = rand() % 5;

    if( choice == 0 )
    {
        return root;
    }
    else if( choice &gt;= 1 &amp;&amp; choice &lt;= 2 &amp;&amp; root-&gt;left != 0)
    {
        return getRandomNodeInBST(root-&gt;left);
    }
    else if( choice &gt;= 3 &amp;&amp; choice &lt;= 4 &amp;&amp; root-&gt;right != 0)
    {
        return getRandomNodeInBST(root-&gt;right);
    }

    return root;
}

// This is not an efficient way to create a BST (copies needlessly), but let's 
// aim for code that's not hard to read here.
BinarySearchTree makeBST()
{
    BinarySearchTree bst;

    bst.insert(7);
    bst.insert(3);
    bst.insert(10);
    bst.insert(2);
    bst.insert(4);
    bst.insert(777);
    bst.insert(500);
    bst.insert(1001);

    assert (bst.find(12345) == 0);
    assert (bst.find(bst.getRoot()-&gt;value) == bst.getRoot());
    assert (bst.find(bst.getRoot()-&gt;left-&gt;value) == bst.getRoot()-&gt;left);
    assert (bst.find(bst.getRoot()-&gt;right-&gt;value) == bst.getRoot()-&gt;right);
    assert (bst.find(bst.getRoot()-&gt;right-&gt;right-&gt;left-&gt;value) == bst.getRoot()-&gt;right-&gt;right-&gt;left);

    return bst;
}

int main()
{
    cout&lt;&lt;"Begin"&lt;&lt;endl;

    BinarySearchTree bst = makeBST();

    cout&lt;&lt;"Start delete (with no up pointer)."&lt;&lt;endl;

    // Make sure delete doesn't screw-up the BST.
    while( bst.getRoot() != 0 )
    {
        assert ( isValidBST(bst.getRoot()) );

        Node* nDel = getRandomNodeInBST( bst.getRoot() );
        cout&lt;&lt;"Node to delete: "&lt;&lt;nDel-&gt;value&lt;&lt;endl;

        bst.deleteNode( nDel-&gt;value );
    }

    cout&lt;&lt;"End delete"&lt;&lt;endl;

    cout&lt;&lt;"End"&lt;&lt;endl;
    return 0;
}
</code></pre>
<h1>Code Output</h1>
<p><strong>[Inserted file: bst_delNoParent.cpp.out.]</strong></p>
<pre><code>Begin
Start delete (with no up pointer).
2
3
4
7
10
500
777
1001
Node to delete: 10
2
3
4
7
500
777
1001
Node to delete: 3
2
4
7
500
777
1001
Node to delete: 500
2
4
7
777
Node to delete: 2
4
7
777
Node to delete: 4
7
777
Node to delete: 7
777
Node to delete: 777
0
</code></pre>
<h1>Solution Explained</h1>
<p>You need to maintain the fundamental property of the BST: <em>for any node, all left children are smaller, all right children are bigger</em>. </p>
<p>The insight is that once you have located the node to delete (just traverse the tree), you can establish a deletion convention. You can obey the above invariant of BSTs with deleting the node which value comes just before the node to delete (the rightmost node of the left child) or the successor (the leftmost node of the right child). Pick one (in this case we picked the successor). Then you just have to swap the node to delete with the successor, then issue a <em>deleteMin</em> on the right child of the node to delete (which happens to be the node we just swapped).</p>
<p><em>deleteMin</em> is easy to implement since it cannot have two children (if it did, it would not be a min). Therefore, you just point the parent to the child and delete the node.</p>